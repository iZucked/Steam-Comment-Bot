<%
	// part 2 of the type fixing hack; once again go over all the genfeatures, but this time
	// 1. find the FQN of any type which has been renamed (using an illegal reflective method access, sorry;
	//		genmodel does not expose many useful methods)
	// 2. restore the name so that other bits of generation do not go wrong
	// 3. postprocess the import list, replacing references to the renamed type appropriately.
	
	{
	final String MMXCORE_ANNOTATION = "http://www.mmxlabs.com/mmxcore/1/MMXCore";
	final String MMXCORE_GENERATED_TYPE = "generatedType";
	final String MMXCORE_ORIGINAL_TYPE = "originalType";
	stringBuffer.append( NL + NL + "// finish type fixing" + NL);
	final HashMap<String, String> replacementFQTs = new HashMap<String, String>();
	for (GenFeature genFeature : (isImplementation ? genClass.getImplementedGenFeatures() : genClass.getDeclaredGenFeatures())) {
		if (genFeature.isReferenceType()) {
			final EReference eReference = (EReference) genFeature.getEcoreFeature();
			final EAnnotation annotation = eReference.getEReferenceType().getEAnnotation(MMXCORE_ANNOTATION);
			if (annotation != null && annotation.getDetails().containsKey(MMXCORE_GENERATED_TYPE)) {
						try {
							final java.lang.reflect.Method m = org.eclipse.emf.codegen.ecore.genmodel.impl.GenBaseImpl.class
									.getDeclaredMethod("getType", GenClass.class,
											EClassifier.class, Boolean.TYPE);
							m.setAccessible(true);
							final String originalfqType = (String) 
									m.invoke(genFeature, genClass,
											eReference.getEReferenceType(),
											true);
							final String replacementfqType = annotation
									.getDetails().get(MMXCORE_GENERATED_TYPE);
							replacementFQTs.put(originalfqType,
									replacementfqType);

						} catch (Throwable e) {
							stringBuffer.append("// something went wrong" + NL);
							stringBuffer.append("/* error : " + e + "*/");
						}
						// undo the naming hack
						((EReference) genFeature.getEcoreFeature())
								.getEReferenceType().setName(
										annotation.getDetails().get(
												MMXCORE_ORIGINAL_TYPE));
						//stringBuffer.append("// restoring name of type from "
						//		+ annotation.getDetails().get(
						//				MMXCORE_GENERATED_TYPE)
						//		+ " to "
						//		+ annotation.getDetails().get(
						//				MMXCORE_ORIGINAL_TYPE) + NL);			
				}
		}
	}

	genModel.emitSortedImports();
	
	String imports = importBuffer.toString();
	for (final Map.Entry<String, String> fqns : replacementFQTs.entrySet()) {
		imports = imports.replace((CharSequence) (fqns.getKey() + ";"), (CharSequence) (fqns.getValue() + ";")); 
	}
	
	stringBuffer.insert(importBufferOffset, imports);

	}
%>