/* // Originally based on example from http://www2.cs.tum.edu/projekte/cup/examples.php */
import java_cup.runtime.*;
import java.util.*;
import com.mmxlabs.common.parser.astnodes.*;
import com.mmxlabs.common.parser.series.*;

parser code {:
    // Constructor, needed for call to scan later
    private Lexer s;
   public Parser(Lexer s){super(s,s.symbolFactory); this.s=s; }
    
    private SeriesParserData seriesParserData;
    public SeriesParserData getSeriesParserData() { return seriesParserData; }
    public void setSeriesParserData(SeriesParserData seriesParserData) { this.seriesParserData = seriesParserData; }
    
    private SeriesParser seriesParser;
    public SeriesParser getSeriesParser() { return seriesParser; }
    public void setSeriesParser(SeriesParser seriesParser) { this.seriesParser = seriesParser; }
    
    // Error capturing
    public List<Symbol> errors = new LinkedList<>();
	public void syntax_error(Symbol s){	errors.add(s); }
    
:}

/* define how to connect to the scanner! */
/*init with {: s.init(); :};*/
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            PLUS, MINUS, TIMES, DIVIDE, UPLUS, UMINUS, LPAREN, RPAREN, COMMA, PERCENT, QUESTION;
terminal			CAP, FLOOR, MIN, MAX, SHIFT, DATEDAVG, SPLITMONTH, S, VOLUMETIERM3, VOLUMETIERMMBTU;

terminal Integer    INTEGER;
terminal Double    NUMBER;
terminal ASTNode    SERIES;       
terminal String NAMED_ELEMENT;

/* Non terminals */
non terminal ASTNode    expr;      // used to store evaluated subexpressions

/* Precedences */
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left DIVIDE;
precedence left PERCENT;
precedence left UPLUS;
precedence left UMINUS;
precedence left INTEGER;
precedence left NUMBER;

/* The grammar rules */


expr      ::= expr:lhs PLUS expr:rhs         {: RESULT = new OperatorASTNode(lhs, rhs, Operator.PLUS);       :}
             | expr:lhs MINUS expr:rhs        {: RESULT = new OperatorASTNode(lhs, rhs, Operator.MINUS);      :}
             | expr:lhs TIMES expr:rhs        {: RESULT = new OperatorASTNode(lhs, rhs, Operator.TIMES);       :}
             | expr:lhs DIVIDE expr:rhs        {: RESULT = new OperatorASTNode(lhs, rhs, Operator.DIVIDE);       :}
             | CAP LPAREN expr:e1 COMMA expr:e2 RPAREN       {: RESULT = new FunctionASTNode(e1, e2, FunctionType.CAP);       :}
             | FLOOR LPAREN expr:e1 COMMA expr:e2 RPAREN       {: RESULT = new FunctionASTNode(e1, e2, FunctionType.FLOOR);       :}
             | MIN LPAREN expr:e1 COMMA expr:e2 RPAREN       {: RESULT = new FunctionASTNode(e1, e2, FunctionType.MIN);       :}
             | MAX LPAREN expr:e1 COMMA expr:e2 RPAREN       {: RESULT = new FunctionASTNode(e1, e2, FunctionType.MAX);       :}
             | INTEGER:lhs PERCENT expr:rhs                 {: RESULT = new OperatorASTNode(new ConstantASTNode(lhs), rhs, Operator.PERCENT); :}
             | NUMBER:lhs PERCENT expr:rhs                 {: RESULT = new OperatorASTNode(new ConstantASTNode(lhs), rhs, Operator.PERCENT); :}
             | QUESTION:lhs PERCENT expr:rhs               {: RESULT = new OperatorASTNode(new BreakEvenASTNode(), rhs, Operator.PERCENT); :}  
             %prec PERCENT
             | SHIFT LPAREN expr:e1 COMMA INTEGER:i1 RPAREN       {: RESULT = new ShiftFunctionASTNode(e1, i1);       :}
             | SHIFT LPAREN expr:e1 COMMA MINUS INTEGER:i1 RPAREN       {: RESULT = new ShiftFunctionASTNode(e1, -i1);       :}
             | DATEDAVG LPAREN expr:lhs COMMA INTEGER:n1 COMMA INTEGER:n2 COMMA INTEGER:n3 RPAREN  {: RESULT =  new DatedAvgFunctionASTNode(lhs, n1, n2, n3); :}
             | VOLUMETIERM3 LPAREN expr:low COMMA NUMBER:n1 COMMA expr:high RPAREN  {: RESULT =  new VolumeTierASTNode(true, low, n1, high); :}
             | VOLUMETIERMMBTU LPAREN expr:low COMMA NUMBER:n1 COMMA expr:high RPAREN  {: RESULT =  new VolumeTierASTNode(false, low, n1, high); :}             
             | SPLITMONTH LPAREN expr:e1 COMMA expr:e2 COMMA INTEGER:s RPAREN  {: RESULT =  new SplitMonthFunctionASTNode(e1, e2, s); :}
             | S LPAREN expr:base COMMA NUMBER:lower COMMA NUMBER:higher COMMA NUMBER:a1 COMMA NUMBER:b1 COMMA NUMBER:a2 COMMA NUMBER:b2 COMMA NUMBER:a3 COMMA NUMBER:b3 RPAREN  {: RESULT =  new SCurveFunctionASTNode(base, lower, higher, a1,b1,a2,b2,a3,b3); :}             
             | MINUS expr:e                 {: RESULT = new MinusASTNode(e);        :}
  	     %prec UMINUS
             | PLUS expr:e                 {: RESULT = e;         :}
  	     %prec UPLUS
       | LPAREN expr:e RPAREN	         {: RESULT = e;           :}
       | SERIES:n	                     {: RESULT = n;           :}
       | NAMED_ELEMENT:n	                     {: RESULT = seriesParser.getNamedSeriesASTNode(n);           :}
       | NUMBER:n	                     {: RESULT =  new ConstantASTNode(n);           :}
       | INTEGER:n	                     {: RESULT =  new ConstantASTNode(n);           :}
       | QUESTION:n	                     {: RESULT =  new BreakEvenASTNode();           :}
             ;     
             
